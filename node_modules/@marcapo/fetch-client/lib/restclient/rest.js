import { FetchClientResponse } from "./response";
class RestClient {
    constructor(baseUrl, additionalHeaders) {
        this.baseUrl = `${baseUrl}`;
        this.additionalHeaders = additionalHeaders || {};
    }
    baseUrl;
    additionalHeaders;
    parseQueryObject(query) {
        if (!query) {
            return "";
        }
        let queryString = ``;
        Object.keys(query).forEach((key, idx) => {
            queryString = `${queryString}${idx === 0 ? "?" : "&"}${key}=${query[key]}`;
        });
        return queryString;
    }
    async handleRequest(method, url, config, body, otherType) {
        if (!url.startsWith("/")) {
            url = `/${url}`;
        }
        let requestHeader;
        let requestBody;
        if (otherType === "formData") {
            requestHeader = {};
            requestBody = body;
        }
        else {
            requestHeader = Object.assign(this.additionalHeaders, { "Content-Type": "application/json" });
            requestBody = JSON.stringify(body);
        }
        if (method === "GET") {
            return fetch(encodeURI(`${this.baseUrl}${url}`), {
                method,
                headers: requestHeader,
                credentials: "include",
                ...config,
            }).then(res => this.handleResponse(res, otherType));
        }
        return fetch(encodeURI(`${this.baseUrl}${url}`), {
            method,
            body: requestBody,
            headers: requestHeader,
            credentials: "include",
            ...config,
        }).then(res => this.handleResponse(res, otherType));
    }
    async handleResponse(response, type) {
        const clientResponse = new FetchClientResponse();
        const cloned = response.clone();
        if (!response.ok) {
            clientResponse.success = false;
            console.error(response.statusText);
        }
        else {
            clientResponse.success = true;
        }
        try {
            if (type === "excel") {
                clientResponse.data = (await response.arrayBuffer());
            }
            else {
                clientResponse.data = await response.json();
            }
        }
        catch (e) {
            clientResponse.data = (await cloned.text());
        }
        clientResponse.status = response.status;
        clientResponse.statusText = response.statusText;
        clientResponse.headers = response.headers;
        return clientResponse;
    }
    async get(url, { query, config } = {}) {
        return this.handleRequest("GET", `${url}${this.parseQueryObject(query)}`, config);
    }
    async patch(url, { body, query, config, otherType } = {}) {
        return this.handleRequest("PATCH", `${url}${this.parseQueryObject(query)}`, config, body, otherType);
    }
    async put(url, { body, query, config, otherType } = {}) {
        return this.handleRequest("PUT", `${url}${this.parseQueryObject(query)}`, config, body, otherType);
    }
    async post(url, { body, query, config, otherType } = {}) {
        return this.handleRequest("POST", `${url}${this.parseQueryObject(query)}`, config, body, otherType);
    }
    async delete(url, { body, query, config, otherType } = {}) {
        return this.handleRequest("DELETE", `${url}${this.parseQueryObject(query)}`, config, body, otherType);
    }
}
export { RestClient };
