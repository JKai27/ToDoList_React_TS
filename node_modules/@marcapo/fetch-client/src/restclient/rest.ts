import { GatewayserviceBaseUrl } from "./gatwayservices";
import { ClientResponse, IConfigProps, IRequestProps } from "./interfaces";
import { FetchClientResponse } from "./response";

class RestClient {
	constructor(baseUrl: GatewayserviceBaseUrl, additionalHeaders?: HeadersInit) {
		this.baseUrl = `${baseUrl}`;
		this.additionalHeaders = additionalHeaders || {};
	}
	private baseUrl;
	private additionalHeaders;

	private parseQueryObject(query?: Record<string | number, string | number>): string {
		if (!query) {
			return "";
		}
		let queryString = ``;
		Object.keys(query).forEach((key, idx) => {
			queryString = `${queryString}${idx === 0 ? "?" : "&"}${key}=${query[key]}`;
		});
		return queryString;
	}

	private async handleRequest<T>(
		method: string,
		url: string,
		config?: IConfigProps,
		body?: Record<string, any>,
		otherType?: "formData" | "excel"
	): ClientResponse<T> {
		if (!url.startsWith("/")) {
			url = `/${url}`;
		}

		let requestHeader;

		let requestBody;

		if (otherType === "formData") {
			requestHeader = {};
			requestBody = body as FormData;
		} else {
			requestHeader = Object.assign(this.additionalHeaders, { "Content-Type": "application/json" });
			requestBody = JSON.stringify(body);
		}

		if (method === "GET") {
			return fetch(encodeURI(`${this.baseUrl}${url}`), {
				method,
				headers: requestHeader,
				credentials: "include",
				...config,
			}).then(res => this.handleResponse(res, otherType));
		}
		return fetch(encodeURI(`${this.baseUrl}${url}`), {
			method,
			body: requestBody,
			headers: requestHeader,
			credentials: "include",
			...config,
		}).then(res => this.handleResponse(res, otherType));
	}

	private async handleResponse<T>(response: Response, type?: "formData" | "excel"): ClientResponse<T> {
		const clientResponse = new FetchClientResponse<T>();
		const cloned = response.clone();
		if (!response.ok) {
			clientResponse.success = false;
			console.error(response.statusText);
		} else {
			clientResponse.success = true;
		}
		try {
			if (type === "excel") {
				clientResponse.data = (await response.arrayBuffer()) as T;
			} else {
				clientResponse.data = await response.json();
			}
		} catch (e) {
			clientResponse.data = (await cloned.text()) as T;
		}
		clientResponse.status = response.status;
		clientResponse.statusText = response.statusText;
		clientResponse.headers = response.headers;
		return clientResponse;
	}
	public async get<T>(url: string, { query, config }: IRequestProps = {}): ClientResponse<T> {
		return this.handleRequest("GET", `${url}${this.parseQueryObject(query)}`, config);
	}

	public async patch<T>(url: string, { body, query, config, otherType }: IRequestProps = {}): ClientResponse<T> {
		return this.handleRequest("PATCH", `${url}${this.parseQueryObject(query)}`, config, body, otherType);
	}

	public async put<T>(url: string, { body, query, config, otherType }: IRequestProps = {}): ClientResponse<T> {
		return this.handleRequest("PUT", `${url}${this.parseQueryObject(query)}`, config, body, otherType);
	}

	public async post<T>(url: string, { body, query, config, otherType }: IRequestProps = {}): ClientResponse<T> {
		return this.handleRequest("POST", `${url}${this.parseQueryObject(query)}`, config, body, otherType);
	}

	public async delete<T>(url: string, { body, query, config, otherType }: IRequestProps = {}): ClientResponse<T> {
		return this.handleRequest("DELETE", `${url}${this.parseQueryObject(query)}`, config, body, otherType);
	}
}

export { RestClient };
