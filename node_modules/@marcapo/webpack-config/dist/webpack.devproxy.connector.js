"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.connectToShellWebSocket = void 0;
const child_process_1 = require("child_process");
const ws_1 = __importDefault(require("ws"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const glob_1 = require("glob");
const connectToShellWebSocket = ({ websocketServerLocation, remotes, }) => {
    const ws = new ws_1.default(websocketServerLocation);
    ws.onopen = () => {
        ws.send(JSON.stringify({ remotes }));
        let buildInProgress = false;
        fs_extra_1.default.watch("src", { recursive: true }).on("change", () => {
            console.log("rebuild triggerd");
            if (!buildInProgress) {
                buildInProgress = true;
                void (0, child_process_1.exec)("npm run build:types").on("exit", () => {
                    const globFiles = (0, glob_1.sync)(`lib/src/**/*.d.ts`);
                    const typeFiles = globFiles.map(entry => ({
                        fileName: entry,
                        data: fs_extra_1.default.readFileSync(entry).toString(),
                    }));
                    ws.send(JSON.stringify({ types: typeFiles }), () => {
                        console.log("back from WS sending data");
                        buildInProgress = false;
                    });
                });
            }
        });
    };
    ws.onerror = error => {
        console.log(error.message);
    };
    ws.onmessage = message => {
        try {
            const typeData = JSON.parse(message.data);
            console.log("recieving new type data for ", typeData.service);
            const path = `node_modules/${typeData.service}`;
            typeData.data.forEach(entry => {
                const pathToWrite = `${path}/${entry.fileName}`;
                console.log("writing ", pathToWrite);
                const tempPathArr = pathToWrite.split("/");
                tempPathArr.pop();
                const pathToEnsure = tempPathArr.join("/");
                fs_extra_1.default.ensureDirSync(pathToEnsure);
                fs_extra_1.default.writeFileSync(pathToWrite, entry.data);
            });
        }
        catch (e) {
            console.log(e);
        }
    };
    ws.onclose = () => {
        console.log(`[${Date.now().toLocaleString()}] host offline, try to reconnect`);
        // Try to reconnect in 5 seconds
        setTimeout(() => {
            connectToShellWebSocket({ websocketServerLocation, remotes });
        }, 5000);
    };
};
exports.connectToShellWebSocket = connectToShellWebSocket;
