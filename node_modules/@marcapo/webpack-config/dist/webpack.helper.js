"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRemoteDependenciesWithVersion = exports.parseMfeConfigJson = exports.extractDependenciesWithoutRemotes = void 0;
const semver_1 = require("semver");
const getCleanProjectName = (name) => name.replace("@marcapo/", "");
const getSuperCleanProjectName = (name) => name.replace("@marcapo/", "").replaceAll("-", "_");
// const getRemoteStringWithVersion = ({ dependency, version }: { dependency: string; version: string }) => {
// 	const requestedVersion = `${major(version)}.${minor(version)}`;
// 	return `${getSuperCleanProjectName(dependency)}@/js/${getCleanProjectName(
// 		dependency
// 	)}/${requestedVersion}/remoteEntry.js}`;
// };
const promiseApiString = ({ dependency, version, }) => `promise new Promise(resolve => {
      const url = "/js/${getCleanProjectName(dependency)}/${(0, semver_1.major)(version)}.${(0, semver_1.minor)(version)}/remoteEntry.js"
      const cacheBustingParam = 'cb=' + new Date().getTime();
      const remoteUrlWithCacheBust = url + '?' + cacheBustingParam;
	  console.log('Loading remote script:', remoteUrlWithCacheBust);
      const script = document.createElement('script')
      script.src = remoteUrlWithCacheBust
      script.onload = () => {
	  console.log("Remote script loaded succesfully");
	  if (window.${getSuperCleanProjectName(dependency)}) {
	   const proxy = {
	    get: (request) => window.${getSuperCleanProjectName(dependency)}.get(request),
	    init: (...arg) => {
         try {
          return window.${getSuperCleanProjectName(dependency)}.init(...arg)
         } catch(e) {
          console.log('remote container already initialized')
         }
        }
       }
       resolve(proxy)
      } else {
        reject(new Error ('Failed to load remote, window.${getSuperCleanProjectName(dependency)} is undefined'))}
      }
      document.head.appendChild(script);
    })
    `;
const parseMfeConfigJson = (mfeConfigJson, packageLock, packageJson) => {
    const remotes = {};
    mfeConfigJson.remotes.forEach(dependency => {
        try {
            const packageLockVersion = packageLock.lockfileVersion;
            console.log("package-lock-version: ", packageLockVersion);
            let version = null;
            if (packageLockVersion === 3) {
                version = packageLock.packages[`node_modules/${dependency}`]?.version;
            }
            else if (packageLockVersion === 2) {
                version = packageLock.dependencies[dependency]?.version;
            }
            Object.assign(remotes, { [dependency]: promiseApiString({ dependency, version }) });
        }
        catch (_) {
            throw new Error(`[CONFIG] Error: ${dependency} requested as remote, but not present in package.json!!!`);
        }
    });
    console.log({ remotes });
    return {
        exposes: mfeConfigJson.exposes,
        remotes,
        filename: "remoteEntry.js",
        name: getSuperCleanProjectName(packageJson.name),
    };
};
exports.parseMfeConfigJson = parseMfeConfigJson;
const getRemoteDependenciesWithVersion = ({ dependencies, remotes, }) => {
    const depsWithVersion = {};
    Object.keys(dependencies).forEach(dependency => {
        if (remotes.includes(dependency)) {
            Object.assign(depsWithVersion, { [dependency]: dependencies[dependency] });
        }
    });
    return depsWithVersion;
};
exports.getRemoteDependenciesWithVersion = getRemoteDependenciesWithVersion;
const extractDependenciesWithoutRemotes = ({ remotes, dependencies, }) => {
    const dependenciesWithoutRemotes = {};
    Object.keys(dependencies).forEach(key => {
        if (!remotes.includes(key)) {
            Object.assign(dependenciesWithoutRemotes, { [key]: dependencies[key] });
        }
    });
    return dependenciesWithoutRemotes;
};
exports.extractDependenciesWithoutRemotes = extractDependenciesWithoutRemotes;
