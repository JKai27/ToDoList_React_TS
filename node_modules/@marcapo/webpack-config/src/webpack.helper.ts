import { ModuleFederationPluginOptions } from "@module-federation/utilities";
import { PackageJson } from "types-package-json";
import { minor, major } from "semver";

interface IMfeConfigJson {
	remotes: string[];
	exposes: Record<string, string>;
	customPlugins: any[];
	customPort?: string | number;
	customConfig?: any;
	outputPath?: string;
}
export interface IResolvedDependency {
	version: string;
	resolved: string;
	integrity: string;
	requires: Record<string, IResolvedDependency>;
}

interface IMfeProxyJson {
	path: string | RegExp;
	proxy: { target: string; pathRewrite?: Record<string, string>; changeOrigin?: boolean };
}
const getCleanProjectName = (name: string) => name.replace("@marcapo/", "");
const getSuperCleanProjectName = (name: string) => name.replace("@marcapo/", "").replaceAll("-", "_");
// const getRemoteStringWithVersion = ({ dependency, version }: { dependency: string; version: string }) => {
// 	const requestedVersion = `${major(version)}.${minor(version)}`;
// 	return `${getSuperCleanProjectName(dependency)}@/js/${getCleanProjectName(
// 		dependency
// 	)}/${requestedVersion}/remoteEntry.js}`;
// };

const promiseApiString = ({
	dependency,
	version,
}: {
	dependency: string;
	version: string;
}) => `promise new Promise(resolve => {
      const url = "/js/${getCleanProjectName(dependency)}/${major(version)}.${minor(version)}/remoteEntry.js"
      const cacheBustingParam = 'cb=' + new Date().getTime();
      const remoteUrlWithCacheBust = url + '?' + cacheBustingParam;
	  console.log('Loading remote script:', remoteUrlWithCacheBust);
      const script = document.createElement('script')
      script.src = remoteUrlWithCacheBust
      script.onload = () => {
	  console.log("Remote script loaded succesfully");
	  if (window.${getSuperCleanProjectName(dependency)}) {
	   const proxy = {
	    get: (request) => window.${getSuperCleanProjectName(dependency)}.get(request),
	    init: (...arg) => {
         try {
          return window.${getSuperCleanProjectName(dependency)}.init(...arg)
         } catch(e) {
          console.log('remote container already initialized')
         }
        }
       }
       resolve(proxy)
      } else {
        reject(new Error ('Failed to load remote, window.${getSuperCleanProjectName(dependency)} is undefined'))}
      }
      document.head.appendChild(script);
    })
    `;

type ParsedMFEConfig = Pick<ModuleFederationPluginOptions, "exposes" | "remotes" | "library" | "name" | "filename">;

const parseMfeConfigJson = (
	mfeConfigJson: {
		exposes: Record<string, string>;
		remotes: string[];
	},
	packageLock: any,
	packageJson: PackageJson
): ParsedMFEConfig => {
	const remotes = {};
	mfeConfigJson.remotes.forEach(dependency => {
		try {
			const packageLockVersion = packageLock.lockfileVersion;
			console.log("package-lock-version: ", packageLockVersion);
			let version = null;
			if (packageLockVersion === 3) {
				version = packageLock.packages[`node_modules/${dependency}`]?.version;
			} else if (packageLockVersion === 2) {
				version = packageLock.dependencies[dependency]?.version;
			}
			Object.assign(remotes, { [dependency]: promiseApiString({ dependency, version }) });
		} catch (_) {
			throw new Error(`[CONFIG] Error: ${dependency} requested as remote, but not present in package.json!!!`);
		}
	});
	console.log({ remotes });
	return {
		exposes: mfeConfigJson.exposes,
		remotes,
		filename: "remoteEntry.js",
		name: getSuperCleanProjectName(packageJson.name),
	};
};

const getRemoteDependenciesWithVersion = ({
	dependencies,
	remotes,
}: {
	dependencies: Record<string, string>;
	remotes: string[];
}) => {
	const depsWithVersion = {};
	Object.keys(dependencies).forEach(dependency => {
		if (remotes.includes(dependency)) {
			Object.assign(depsWithVersion, { [dependency]: dependencies[dependency] });
		}
	});
	return depsWithVersion;
};
const extractDependenciesWithoutRemotes = ({
	remotes,
	dependencies,
}: {
	remotes: string[];
	dependencies: Record<string, string>;
}) => {
	const dependenciesWithoutRemotes = {};
	Object.keys(dependencies).forEach(key => {
		if (!remotes.includes(key)) {
			Object.assign(dependenciesWithoutRemotes, { [key]: dependencies[key] });
		}
	});
	return dependenciesWithoutRemotes;
};

export {
	ParsedMFEConfig,
	extractDependenciesWithoutRemotes,
	IMfeConfigJson,
	IMfeProxyJson,
	parseMfeConfigJson,
	getRemoteDependenciesWithVersion,
};
