import path from "path";
import webpack from "webpack";
import ForkTsCheckerWebpackPlugin from "fork-ts-checker-webpack-plugin";
import { PackageJson } from "types-package-json";
import ReactRefreshWebpackPlugin from "@pmmmwh/react-refresh-webpack-plugin";
import MinifiPlugin from "mini-css-extract-plugin";
import { generateDevServer } from "./webpack.devserver";
import {
	IMfeConfigJson,
	IMfeProxyJson,
	extractDependenciesWithoutRemotes,
	getRemoteDependenciesWithVersion,
	parseMfeConfigJson,
} from "./webpack.helper";

const generateWebpackConfig = ({
	packageJson,
	packageLock,
	containingDirPath,
	entryFilePath,
	mfeConfig,
	proxys,
	tempDevFix,
	defaultRemotes = [],
}: {
	packageJson: PackageJson;
	packageLock: Record<string, any>;
	containingDirPath: string;
	mfeConfig: IMfeConfigJson;
	entryFilePath: string;
	proxys: IMfeProxyJson[];
	tempDevFix?: boolean;
	defaultRemotes?: string[];
}) => {
	const { name, dependencies, version } = packageJson;
	const { remotes, exposes, outputPath, customPort, customPlugins, customConfig } = mfeConfig;

	const combinedRemotes = remotes.concat(defaultRemotes);

	if (!dependencies) {
		throw new Error("Dependency property missing in package.json");
	}
	const sharedDependencies = extractDependenciesWithoutRemotes({ dependencies, remotes: combinedRemotes });
	const { ModuleFederationPlugin } = webpack.container;
	require("dotenv").config({ path: "./.env" });
	let newName = "";
	if (name.includes("@")) {
		newName = name.split("@marcapo/")[1];
	}
	const parsedMfeConfig = parseMfeConfigJson({ remotes: combinedRemotes, exposes }, packageLock, packageJson);
	console.log(parseMfeConfigJson);
	const ModuleFederationConfig = new ModuleFederationPlugin({
		...parsedMfeConfig,
		shared: {
			...sharedDependencies,
			antd: {
				singleton: true,
			},
			"@marcapo/resource-components": {},
			mobx: {
				singleton: true,
				eager: true,
				requiredVersion: dependencies.mobx,
			},
			"mobx-react-lite": {
				singleton: true,
				eager: true,
				requiredVersion: dependencies["mobx-react-lite"],
			},
			react: tempDevFix ? { eager: true } : { singleton: true, eager: true, requiredVersion: dependencies.react },
			"react-dom": tempDevFix
				? { eager: true }
				: {
						singleton: true,
						eager: true,
						requiredVersion: dependencies["react-dom"],
				  },
			"react-router-dom": {
				singleton: true,
				requiredVersion: dependencies["react-router-dom"],
			},
		},
	});
	const webpackConfig = {
		...customConfig,
		output: {
			uniqueName: `${newName}:${version}`,
			chunkFilename: `${version}_[chunkhash].js`,
		},
		entry: path.join(containingDirPath, entryFilePath),
		mode: process.env.NODE_ENV || "development",
		devtool: "eval-source-map",
		devServer: {
			...generateDevServer({
				name,
				remotes: getRemoteDependenciesWithVersion({ dependencies, remotes }),
				proxys,
				customPort,
			}),
			hot: true,
		},
		resolve: {
			extensions: [".ts", ".tsx", ".js"],
			fallback: {
				path: require.resolve("path-browserify"),
				fs: false,
			},
			alias: {
				react: path.resolve(containingDirPath, "node_modules/react"),
				React: path.resolve(containingDirPath, "node_modules/react"),
			},
		},
		module: {
			rules: [
				{
					test: /\.module\.css$/,
					use: [
						"style-loader",
						{
							loader: "css-loader",
							options: {
								modules: {
									localIdentName: `[local]__${newName}`,
								},
								importLoaders: 1,
							},
						},
					],
					exclude: /node_modules/,
				},
				{
					test: /\.css$/i,
					use: [MinifiPlugin.loader, "css-loader"],
				},
				// {
				// 	test: /^(?!.*\.module\.css$).*\.css$/,
				// 	use: ["style-loader", "css-loader"],
				// },
				{
					test: /\.(woff|woff2|eot|ttf|otf)$/i,
					type: "asset/resource",
				},
				{
					test: /\.(js|jsx|tsx|ts)$/,
					loader: "ts-loader",
					exclude: /node_modules/,
				},
				{
					test: /\.(js|jsx|tsx|ts)$/,
					loader: "babel-loader",
					exclude:
						/\.\/node_modules(\/@marcapo\/cra-module-root\/node_modules)?\/antd\/[a-z]{2}\/locale\/[a-z]{2}_[A-Z]{2}\.d\.ts/,
					options: {
						cacheDirectory: true,
						babelrc: false,
						presets: [
							["@babel/preset-env", { targets: { browsers: "last 2 versions" } }],
							"@babel/preset-typescript",
							[
								"@babel/preset-react",
								{
									runtime: "automatic",
								},
							],
						],
					},
				},
			],
		},
		watchOptions: {
			ignored: /node_modules(?!\/@marcapo)/,
		},
		plugins: [
			new MinifiPlugin(),
			new webpack.DefinePlugin({
				"process.env": JSON.stringify(process.env),
			}),
			new ReactRefreshWebpackPlugin({ overlay: false }),
			ModuleFederationConfig,
			new ForkTsCheckerWebpackPlugin(),
		],
	};
	if (outputPath) {
		Object.assign(webpackConfig.output, { path: outputPath });
	}
	if (customPlugins.length > 0) {
		webpackConfig.plugins = webpackConfig.plugins.concat(customPlugins);
	}
	return webpackConfig;
};

export { generateWebpackConfig };
