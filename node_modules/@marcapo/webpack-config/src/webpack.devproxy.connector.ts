import { exec } from "child_process";
import WebSocket from "ws";
import fs from "fs-extra";
import { sync } from "glob";

const connectToShellWebSocket = ({
	websocketServerLocation,
	remotes,
}: {
	websocketServerLocation: string;
	remotes: Record<string, string>;
}) => {
	const ws = new WebSocket(websocketServerLocation);
	ws.onopen = () => {
		ws.send(JSON.stringify({ remotes }));
		let buildInProgress = false;
		fs.watch("src", { recursive: true }).on("change", () => {
			console.log("rebuild triggerd");
			if (!buildInProgress) {
				buildInProgress = true;
				void exec("npm run build:types").on("exit", () => {
					const globFiles = sync(`lib/src/**/*.d.ts`);
					const typeFiles = globFiles.map(entry => ({
						fileName: entry,
						data: fs.readFileSync(entry).toString(),
					}));
					ws.send(JSON.stringify({ types: typeFiles }), () => {
						console.log("back from WS sending data");
						buildInProgress = false;
					});
				});
			}
		});
	};
	ws.onerror = error => {
		console.log(error.message);
	};
	ws.onmessage = message => {
		try {
			const typeData: { data: { fileName: string; data: string }[]; service: string } = JSON.parse(
				(message as any).data
			);
			console.log("recieving new type data for ", typeData.service);
			const path = `node_modules/${typeData.service}`;
			typeData.data.forEach(entry => {
				const pathToWrite = `${path}/${entry.fileName}`;
				console.log("writing ", pathToWrite);
				const tempPathArr = pathToWrite.split("/");
				tempPathArr.pop();
				const pathToEnsure = tempPathArr.join("/");
				fs.ensureDirSync(pathToEnsure);
				fs.writeFileSync(pathToWrite, entry.data);
			});
		} catch (e) {
			console.log(e);
		}
	};
	ws.onclose = () => {
		console.log(`[${Date.now().toLocaleString()}] host offline, try to reconnect`);
		// Try to reconnect in 5 seconds
		setTimeout(() => {
			connectToShellWebSocket({ websocketServerLocation, remotes });
		}, 5000);
	};
};

export { connectToShellWebSocket };
